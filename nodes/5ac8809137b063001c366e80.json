{
  "_id": "5ac8809137b063001c366e80",
  "nodeId": "5ac47ae265eb53001d56081e",
  "type": "react_component:0.0.1:local:98912hd89",
  "data": {
    "version": "1",
    "key": "151a6c43-2ab5-4c52-acae-dd303b0c92f1",
    "code": "(()=>{\n  \n  \n  let __parsedFiles = {};\n  function jsonParse(key, contents){\n    if(__parsedFiles[key]){\n      return __parsedFiles[key]\n    }\n  \n    __parsedFiles[key] = JSON.parse(contents);\n    return __parsedFiles[key];\n  \n  }\n  \n  \n  \n  return new Promise(async (resolve,reject)=>{\n    try {\n      \n      const AceEditor = universe.AceEditor;\n      const ReactResizeDetector = universe.ReactResizeDetector;\n      const RecreateChildOnPropsChange = universe.RecreateChildOnPropsChange;\n      \n      const Link = universe.ReactRouterDomLink;\n      \n      class EmbeddedComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        \n        render(){\n          return (\n            <div>\n              embeddedComponenthere\n            </div>\n          )\n        }\n      }\n      \n      class ErrorComponent extends React.Component {\n        constructor(props){\n          super(props);\n        }\n        render(){\n          return (\n            <div>\n              ErrorLoading\n            </div>\n          )\n        }\n      }\n      \n      class mycomponent extends React.Component {\n        constructor(props){\n          super(props);\n          this.state = {\n            appNode: null, // populated after an App in the store is clicked \n            appBaseNode: null, // node from actual app repo \n            storeApps: [], // apps in the store // expecting \"type:appstore_github\" nodes\n          }\n        }\n        \n        componentDidMount(){\n          \n          // storeNode must exist! \n          // - redirect if not\n          if(!this.props.state.storeNode){\n            console.log('Missing this.props.state.storeNode');\n            this.props.history.push('/');\n            return;\n          }\n          \n          console.log('Mounted MainExternalGitHubAppStoreComponent');\n          \n          this.fetchAll();\n          universe.EE.on('nodes-modified', this.fetchAll);\n          \n        }\n        componentWillUnmount(){\n          universe.EE.removeListener('nodes-modified', this.fetchAll);\n        }\n        \n        @autobind\n        async countInstallNodes(){\n          \n          let appBaseNode = this.state.appBaseNode;\n          \n          let installTotal = 1;\n          const countNodes = (childNodes) => {\n            return new Promise(async (resolve, reject)=>{\n    \n              console.log('Saving children');\n              \n              for(let tmpNode of childNodes){\n                installTotal++;\n                if(tmpNode.nodes && tmpNode.nodes.length){\n                  await countNodes(tmpNode.nodes);\n                }\n              }\n              resolve();\n            });\n          }\n          \n          await countNodes(appBaseNode.nodes);\n          \n          this.setState({\n            installTotal\n          });\n          \n        }\n        \n        @autobind\n        async fetchAll(){\n          \n          await this.fetchStoreApps();\n          \n        }\n        \n        @autobind\n        fetchStoreApps(props){\n          // fetch apps for store \n          // - apps.json in repo \n          \n          props = props || this.props;\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n                \n            try {\n                \n              let url = this.props.state.storeNode.data.url; // appstore_github \n              let ghUrl = universe.parseGitHubUrl(url);\n              const gh = new universe.GitHub();\n              // {\n              //   username: ghUser,\n              //   password: ghToken\n              // });\n              \n              let Repo = gh.getRepo(ghUrl.owner, ghUrl.name);\n              let apps = await Repo.getContents('master','apps.json');\n              \n              console.log('GH Apps Result:', apps);\n              apps = WINDOW.atob(apps.data.content);\n              apps = JSON.parse(apps); // should be an array of nodes \n              // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                storeApps: apps\n              })\n              \n            }catch(err){\n              console.error('Failed fetchStoreApps', err);\n            }\n      \n          });\n          \n          \n        }\n        \n        @autobind\n        fetchAppNodes(props){\n          // fetch nodes for App from github repo \n          \n          props = props || this.props;\n          \n          // \n          return new Promise(async (resolve,reject)=>{\n              \n            // let gh = universe.parseGitHubUrl(url);\n            let appNode = this.state.appNode;\n            \n            console.log('Selected appNode:', appNode);\n            \n            let url = `https://github.com/${appNode.data.repo}/archive/${appNode.data.branch || 'master'}.zip`;\n        \n            // cannot simply follow github zipball/tarball links :( \n            universe.fetch(`https://cors-anywhere.herokuapp.com/${url}`,{\n              // mode: 'no-cors' \n            })\n            .then(response=>{\n              // console.log('Response:', response);\n              return response.arrayBuffer();\n            })\n            .then(universe.JSZip.loadAsync)\n            .then(async (zip)=>{\n              \n              console.log('loaded zip data!', zip);\n      \n              // ZIP is valid! \n              let files = zip.files;\n      \n              function readFilePath(p){\n                return new Promise(async (resolve,reject)=>{\n                  console.log('path:', p);\n                  let r = await files[p].async('text')\n                  resolve(r);\n                });\n              }\n      \n              // load all the files \n              let allFiles = {};\n              for(let filepath of Object.keys(files)){\n                let file = files[filepath];\n                if(file.dir){\n      \n                } else {\n                  // console.log('filepath:', filepath);\n                  let contents = await readFilePath(filepath);\n                  // console.log('contents:', contents);\n                  let normalizedPath = filepath.split('/').splice(1).join('/');\n                  allFiles[normalizedPath] = contents;\n                }\n              }\n      \n              console.log('allFiles from Zip1:', allFiles);\n              \n              function addChildren(id){\n                return new Promise(async (resolve,reject)=>{\n                \n                  let nodes = [];\n                  for(let filepath of Object.keys(allFiles)){\n                    let contents = allFiles[filepath];\n                    if(filepath.indexOf('nodes/') !== 0){\n                      // console.log('NOT NODE:', filepath);\n                      continue;\n                    }\n      \n                    let parsed = jsonParse(filepath, contents);\n                    if(parsed.nodeId == id){\n                      // console.log('Matches ID:', parsed.nodeId, id);\n                      let children = await addChildren(parsed._id);\n                      parsed.nodes = children;\n                      nodes.push(parsed);\n                    } else {\n                      // console.log('No Kids:', id, parsed.nodeId);\n                    }\n      \n                  }\n    \n                  resolve(nodes);\n                  \n                });\n              }\n              \n              console.log('Re-organize child nodes');\n              \n              // re-organize child nodes \n              let nodes;\n              try {\n                \n                nodes = await addChildren(null); // start at root, adds children recursively \n        \n              }catch(err){\n                console.error('Failed zipnodes', err);\n                WINDOW.alert('Failed fetching zip nodes');\n              }\n              \n              console.log('AppNodes fetched:', nodes);\n              \n              if(!nodes || !nodes.length){\n                WINDOW.alert('Unable to load nodes (missing app_base at root)');\n                return;\n              }\n        \n              // // let componentNode = await universe.runInVM(result[0],{});\n              this.setState({\n                appBaseNode: nodes[0]\n              })\n      \n      \n            })\n\n          });\n          \n          \n        }\n        \n        @autobind\n        handleViewApp(node){\n          // TODO: actually fetch the nodes, to count them (fetchAppNodes) \n          this.setState({\n            appNode: node\n          }, this.fetchAppNodes);\n          // },this.countInstallNodes);\n          \n        }\n        \n        @autobind\n        async handleInstall(appNode){\n          // install an app by inserting Nodes into your Second \n          // - needs to be faster than updating individually? (can easily break!) \n          // - after launching, creates an app_data directory \n          \n          // moves entire \"app_base\" over \n          // - launches app's platform:browser nodes \n          \n          console.log('AppNode:', appNode);\n          \n          if(!WINDOW.confirm('Install App?')){\n            return false;\n          }\n          \n          \n          this.setState({\n            installing: true,\n            installCurrent: 0\n          });\n          \n          // TODO: update anything in app_base? \n          // - development, hidden from friends, etc. \n          \n          // iterate\n          // - save this one, then start saving down tree\n          let newNode = {\n            nodeId: null,\n            type: appNode.type,\n            data: JSON.parse(JSON.stringify(appNode.data))\n          }\n          \n          console.log('newNode:', newNode);\n    \n          let savedNode = await this.forceNewNode(newNode, {skipExistingLearnedNodeId: true}, true);\n          \n          console.log('Saved Node');\n          \n          let installCurrent = 1;\n          const saveChildNodes = (nodeId, childNodes) => {\n            return new Promise(async (resolve, reject)=>{\n    \n              console.log('Saving children');\n              \n              for(let tmpNode of childNodes){\n                let newChildNode = {\n                  nodeId,\n                  type: tmpNode.type,\n                  data: tmpNode.data,\n                }\n                let savedChildNode = await this.forceNewNode(newChildNode, {skipExistingLearnedNodeId: true}, true);\n                \n                  installCurrent++;      \n                  this.setState({\n                    installCurrent\n                  });\n                  \n    \n                if(tmpNode.nodes && tmpNode.nodes.length){\n    \n                  await saveChildNodes(savedChildNode.data._id, tmpNode.nodes);\n    \n                }\n              }\n              resolve();\n            });\n          }\n    \n          await saveChildNodes(savedNode.data._id, appNode.nodes);\n          \n          console.log('Done installing');\n          \n          \n          this.setState({\n            installing: false\n          });\n    \n          \n          // Launch immediately \n          if(WINDOW.prompt('Launch App? (y/n)', 'y') == 'y'){\n            console.log('Launching app');\n            this.handleLaunchApp(appNode); // pulls out platform_nodes:browser\n          }\n          \n          \n          \n          \n        }\n        \n        @autobind\n        handleLaunchApp(appNode){\n          \n          // Get name, platform nodes \n          let name = appNode.data.name;\n          let appId = appNode.data.appId;\n          let platformNode = appNode.nodes.find(node=>{\n            return (\n              node.type.split(':')[0] == 'platform_nodes'\n              &&\n              node.data.platform == 'browser'\n            )\n          });\n          \n          if(!platformNode || !platformNode.nodes || !platformNode.nodes.length){\n            return WINDOW.alert('Missing platform_nodes for platform:browser');\n          }\n          \n          // remove nodeId from root nodes \n          let platformNodes = platformNode.nodes.map(node=>{\n            delete node.nodeId;\n            return node;\n          });\n          \n          \n          // launch app!\n          // - exists App Store, updates localStorage through Environment/Platform \n          universe.handleCreateNewSecondFromNodes(name, appId, platformNodes);\n          \n          \n        }\n        \n        @autobind\n        forceNewNode(nodeToSave, opts, skipEvent){\n          return new Promise(async (resolve, reject) => {\n            \n            console.log('NewNode:', nodeToSave);\n                \n            // return resolve({\n            //   saveNewNode: nodeToSave\n            // });\n            \n            \n            // Make request to save Node on remote \n            try {\n              \n              let ExternalIdentityNodes = await universe.searchMemory({\n                filter: {\n                  sqlFilter: {\n                    type: 'external_identity:0.0.1:local:8982f982j92',\n                    data: {\n                      commonName: 'main' // should keep using for browser development! \n                    }\n                  }\n                }\n              });\n              let ExternalIdentityNode = ExternalIdentityNodes[0];\n              \n              let response = await universe.loadAndRunCapability('TalkToSecond',{},{\n                type: 'standard_capability_action:0.0.1:local:298j291bs',\n                data: {\n                  action: 'send',\n                  options: {\n                    ExternalIdentityNode,\n                    RequestNode: {\n                      type: 'run_action_sequence:0.0.1:local:293fh8239hsdf23f',\n                      data: {\n                        actions: [\n                          {\n                            matchActionType: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                            dataForAction: {\n                              type: 'forced_learn_node:0.0.1:local:34907234987sf23',\n                              data: {\n                                optionsNode: {\n                                  type: 'options_generic:0.0.1:local:289f3j29832',\n                                  data: opts || {}\n                                },\n                                dataNode: nodeToSave\n                              }\n                            }\n                          }\n                        ]\n                        \n                      }\n                    }\n                  }\n                }\n              });\n              \n              console.log('NewNode response:', response);\n              \n              // get the new node \n              let savedNode = response.data.actionResponses[0];\n              \n              // console.log('Saved Node:', savedNode);\n              \n              if(skipEvent !== true){\n                try {\n                  universe.EE.emit('nodes-modified', '');\n                }catch(err){\n                  console.error(err);\n                }\n              }\n              \n              return resolve(savedNode);\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            } catch(err){\n              console.error('Failed getting local nodes');\n              \n              // alert('Failed');\n              \n              // this.setState({\n              //   saving: false\n              // })\n              \n            }\n            \n          })\n        }\n        \n        \n        @autobind\n        renderAppNode(node){\n          // \"app_base\" and \"appstore_github_entry\" types only \n          return (\n            <div key={node._id || node.data.name} onClick={e=>this.handleViewApp(node)} style={{cursor:'pointer'}}>\n              <strong>\n                {node.data.name}\n              </strong>\n            </div>\n          )\n        }\n        \n        \n        render(){\n          \n          let appBaseNode = this.state.appBaseNode;\n          \n          let metadataData = this.props.state.storeNode ? this.props.state.storeNode.data :{} ;\n          console.log('metadataData', metadataData);\n          \n          return (\n            <div className=\"flex-main\">\n              <div className=\"flex-left\" style={{padding:'4px'}}>\n                \n                <h2 className=\"title is-5\">\n                  Store: {metadataData.name}\n                </h2>\n                \n                <div>\n                  {\n                    this.state.storeApps.map(this.renderAppNode)\n                  }\n                </div>\n                \n              </div>\n              <div className=\"flex-middle\">\n                \n                \n                {\n                  !appBaseNode ? '':\n                  <div>\n                    <h3 className=\"title is-3\">\n                      {appBaseNode.data.name}\n                    </h3>\n                    <h3 className=\"subtitle is-5\">\n                      {appBaseNode.data.appId} : {appBaseNode.data.release} : {appBaseNode.data.version}\n                    </h3>\n                    \n                    <br />\n                    \n                    <div className=\"field has-addons\">\n                      <div className=\"control\">\n                        <button className={\"button\"} onClick={e=>this.handleInstall(appBaseNode)}>\n                          Install\n                        </button>\n                      </div>\n                      {\n                        !this.state.installing ? '':\n                        <div className=\"control\">\n                          <button className=\"button is-loading\">\n                            &nbsp;\n                          </button>\n                        </div>\n                      }\n                      {\n                        this.state.installing ? \n                          <div className=\"control\">\n                            <button className=\"button\">\n                              {this.state.installCurrent}/{this.state.installTotal}\n                            </button>\n                          </div>\n                        :\n                          <div className=\"control\">\n                            <button className=\"button\">\n                              {this.state.installTotal}\n                            </button>\n                          </div>\n                      }\n                    </div>\n                    \n                  </div>\n                }\n                \n              </div>\n              \n            </div>\n          )\n        }\n      }\n      \n      mycomponent = universe.ReactGlobalState(mycomponent);\n      mycomponent = universe.ReactHelpers(mycomponent);\n      mycomponent = universe.ReactRouterDomWithRouter(mycomponent);\n      \n      \n      resolve({\n        type: 'react_component:0.0.1:local:98912hd89',\n        data: mycomponent\n      });\n      \n    }catch(err){\n      reject({\n        ERROR: true, \n        err: err.toString()\n      });\n    }\n    \n  })\n\n  \n})()",
    "internalId": "MainExternalGitHubAppStoreComponent",
    "author": "-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCcuXovU+RZy85KMqLakYSH1mdV\nWdpEUtgcXUyGyU5hVeTO7BkV/kxeC2upcxOwNnrBOdsvHI3nrrILgt90/hCSHKzx\nhOFLREorGoKtSEHxI7/SnzzlWtV3gT/IP5GVHIyvuJBx3hCti0dH55DZG8iMGZ2y\ncGpV73Dez3hHmeBh6wIDAQAB\n-----END PUBLIC KEY-----"
  },
  "active": true,
  "createdAt": 1523089553763,
  "updatedAt": 1523132692746
}